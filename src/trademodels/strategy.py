from .models.model import TradingSignalModel, ExecutionModel
from .model_results.model_result import ModelResult
from .dataclasses import (
    ProcessedData,
    Order,
    OrderSide,
    OrderType,
    TradingSignals,
)
from .errors import NonMatchingIntervalError

import pandas as pd


class StrategyResult:
    """
    Represents the result of a trading strategy.

    Attributes:
        trading_signal_result (ModelResult): The result of the trading signal model.
        execution_result (ModelResult): The result of the execution model.
        order_size (int): The size of the order.
    """

    def __init__(
        self,
        trading_signal_result: ModelResult,
        execution_result: ModelResult,
        order_size: int,
    ):
        """
        Initialize a StrategyResult object.

        Args:
            trading_signal_result (ModelResult): The result of the trading signal model.
            execution_result (ModelResult): The result of the execution model.
            order_size (int): The size of the order.

        Raises:
            NonMatchingIntervalError: If the intervals of the provided models are of different size.
        """
        if (
            trading_signal_result.interval_length
            != execution_result.interval_length
        ):
            raise NonMatchingIntervalError(
                "The intervals of the provided methods are of different size"
            )

        self.trading_signal_result = trading_signal_result
        self.execution_result = execution_result
        self.order_size = order_size

    def use(self, data: ProcessedData) -> "StrategyEvaluator":
        """
        Applies the strategy to the given processed data and returns a StrategyEvaluator object.

        Args:
            data (ProcessedData): The processed data to apply the strategy on.

        Returns:
            StrategyEvaluator: The StrategyEvaluator object containing the results of the strategy.
        """
        # Predict the trading signals
        signals = self.trading_signal_result.get_output(data, self.order_size)

        # Get the optimal orders using the execution model
        orders = self.execution_result.get_output(data, signals)

        return StrategyEvaluator(
            data, signals, orders, self.execution_result.interval_length
        )


class Strategy:
    """
    Represents a trading strategy that combines a trading signal model and an execution model.

    Attributes:
        trading_signal_model (TradingSignalModel): The trading signal model used by the strategy.
        execution_model (ExecutionModel): The execution model used by the strategy.
    """

    def __init__(
        self,
        trading_signal_model: TradingSignalModel,
        execution_model: ExecutionModel,
    ):
        """
        Initialize a Strategy object.

        Args:
            trading_signal_model (TradingSignalModel): The trading signal model used by the strategy.
            execution_model (ExecutionModel): The execution model used by the strategy.
        """
        self.trading_signal_model = trading_signal_model
        self.execution_model = execution_model

    def train(self, interval_length: int, order_size: int) -> StrategyResult:
        """
        Train the strategy by training the trading signal model and the execution model.

        Args:
            interval_length (int): The length of the interval for training.
            order_size (int): The size of the order for training.

        Returns:
            StrategyResult: The result of the strategy training, including the trading signal result,
            execution result, and order size.
        """
        # Train the trading signal model
        trading_signal_result = self.trading_signal_model.train(
            interval_length
        )

        # Train the execution model
        execution_result = self.execution_model.train(
            interval_length, order_size
        )

        return StrategyResult(
            trading_signal_result, execution_result, order_size
        )


class StrategyEvaluator:
    """
    Class for evaluating a trading strategy based on provided data.

    Attributes:
        data (ProcessedData): The processed data used for evaluation.
        signals (TradingSignals): The trading signals generated by the strategy.
        orders (list[Order]): The list of orders generated by the strategy.
        interval_length (int): The length of the interval used for evaluation.
        signal_times_iter (iter): Iterator for the signal times.
    """

    def __init__(
        self,
        data: ProcessedData,
        signals: TradingSignals,
        orders: list[Order],
        interval_length: int,
        cancel_after_one_minute: bool = False,
        max_volume: int = 20,
    ):
        """
        Initialize the StrategyEvaluator.

        Args:
            data (ProcessedData): The processed data used for evaluation.
            signals (TradingSignals): The trading signals generated by the strategy.
            orders (list[Order]): The list of orders generated by the strategy.
            interval_length (int): The length of the interval used for evaluation.
        """
        self.data = data
        self.signals = signals
        self.orders = orders
        self.interval_length = interval_length
        self.cancel_after_one_minute = cancel_after_one_minute
        self.max_volume = max_volume
        self.signal_times_iter = iter(signal.time for signal in self.signals)

    def evaluate(self, liquidate_after_interval=False):
        """
        Evaluate the trading strategy based on the provided data.

        Args:
            liquidate_after_interval (bool, optional): Flag indicating whether to liquidate outstanding orders after each interval. Defaults to False.

        Returns:
            dict: A dictionary containing the following evaluation results:
                - "Number_owned": List of the number of assets owned at each time step.
                - "Gas_values": List of the gas values at each time step.
                - "Cash": List of the cash values at each time step.
                - "Portfolio_values": List of the portfolio values at each time step.
        """
        # What do we want to know?
        # Time that the order has been executed
        # Cancelled orders?
        # Price

        # Market orders at at the beginning of a minute need the to_time of the previous row

        # Interval starts at HH:00, so we need the bid and ask of the previous row, also look at
        # TODO: compare the executed price to the best price in the interval (or just do it in reinforcement_result direclty?)

        outstanding_orders = []
        next_signal_time = next(self.signal_times_iter)
        cancel_time = next_signal_time + pd.Timedelta(
            minutes=self.interval_length
        )

        order_iter = iter(self.orders)
        next_order = next(order_iter)

        number_bought = 0
        cash = 0
        portfolio_values = []
        gas_values = []
        cash_list = []
        number_owned_list = []
        liquidating = False

        counter = 0

        for index in range(len(self.data)):
            counter += 1
            row = self.data.iloc[index]

            # Extract relevant data
            from_time = row["from_timestamp"]
            to_time = row["to_timestamp"]
            best_bid = row["best_bid"]
            best_ask = row["best_ask"]
            high = row["high"]
            low = row["low"]
            volume = row["volume"]

            if counter == 1000:
                print(from_time)
                counter = 0

            # At beginning of minute

            # Cancel outstanding orders after 5-minute interval
            if from_time >= cancel_time:
                outstanding_orders = [
                    order
                    for order in outstanding_orders
                    if order.time == from_time
                ]

                if liquidate_after_interval:
                    liquidating = True

            # Check if a new interval has started
            if from_time >= next_signal_time:
                next_signal_time = next(
                    self.signal_times_iter,
                    pd.Timestamp(year=3000, month=1, day=1),
                )
                cancel_time = from_time + pd.Timedelta(
                    minutes=self.interval_length
                )
                # Calculate number executed

            # Now at end of minute

            executed_orders = []

            # # Check if outstanding orders were executed
            for order in outstanding_orders:
                if str(order.side) == str(OrderSide.ASK) and volume > 0:
                    if high >= order.price:
                        number_bought -= order.volume
                        cash += order.volume * order.price
                        executed_orders.append(order)
                else:
                    if low <= order.price and volume > 0:
                        number_bought += order.volume
                        cash -= order.volume * order.price
                        executed_orders.append(order)

            outstanding_orders = [
                order
                for order in outstanding_orders
                if order not in executed_orders
            ]

            # TODO: check why there are nan values sometimes
            if liquidating:
                liquidating = False
                prev_row = self.data.iloc[index - 1]

                if number_bought > 0:
                    current_bid = prev_row["best_bid"]
                    if str(current_bid) != "nan":
                        cash += current_bid * number_bought
                elif number_bought < 0:
                    current_ask = prev_row["best_ask"]
                    if str(current_ask) != "nan":
                        cash -= current_ask * abs(number_bought)

                number_bought = 0

            if self.cancel_after_one_minute:
                outstanding_orders = []

            # Put in new orders
            while to_time >= next_order.time:
                if str(next_order.type) == str(OrderType.MARKET_ORDER):
                    if str(next_order.side) == str(OrderSide.ASK):
                        number_bought -= next_order.volume
                        cash += next_order.volume * best_bid
                    else:
                        number_bought += next_order.volume
                        cash -= next_order.volume * best_ask
                elif str(next_order.type) == str(OrderType.LIMIT_ORDER):
                    # Could be executed immediatly
                    if (
                        str(next_order.side) == str(OrderSide.ASK)
                        and next_order.price <= best_bid
                    ):
                        number_bought -= next_order.volume
                        cash += next_order.volume * next_order.price
                    elif (
                        str(next_order.side) == str(OrderSide.BID)
                        and next_order.price >= best_ask
                    ):
                        number_bought += next_order.volume
                        cash -= next_order.volume * next_order.price
                    else:
                        # Otherwise added to the outstanding orders
                        outstanding_orders.append(next_order)

                next_order = next(
                    order_iter,
                    Order(0, 0, 0, 0, pd.Timestamp(year=3000, month=1, day=1)),
                )

            gas_value = number_bought * (best_bid + best_ask) / 2
            portfolio_value = cash + gas_value
            portfolio_values.append(portfolio_value)
            gas_values.append(gas_value)
            cash_list.append(cash)
            number_owned_list.append(number_bought)

        return {
            "Number_owned": number_owned_list,
            "Gas_values": gas_values,
            "Cash": cash_list,
            "Portfolio_values": portfolio_values,
        }


class StrategyEvaluatorRL(StrategyEvaluator):
    """
    A class for evaluating a trading strategy using reinforcement learning.
    Inherits from StrategyEvaluator.
    """

    def __init__(
        self,
        data: ProcessedData,
        interval_starts: list[pd.Timestamp],
        orders: list[Order],
        interval_length: int,
        cancel_after_one_minute: bool = False,
        max_volume: int = 20,
    ):
        """
        Initialize the StrategyEvaluatorRL object.

        Args:
            data (ProcessedData): The processed data used for evaluation.
            interval_starts (list[pd.Timestamp]): List of interval start times.
            orders (list[Order]): List of orders.
            interval_length (int): Length of each interval in minutes.
        """
        self.data = data
        self.interval_starts = interval_starts
        self.orders = orders
        self.interval_length = interval_length
        self.cancel_after_one_minute = cancel_after_one_minute
        self.signal_times_iter = iter(self.interval_starts)
        self.max_volume = max_volume
